4.11.16 (~5ч)
+Установить Visual Studio, проверить запуск проекта UWP.
+Ознакомиться с заданием более подробно.
+Начать проектировать черновой вариант модели пасеки.

5.11.16 (~2ч)
+Установить и настроить ReSharper. Удалить ReSharper (компьютер не тянет).
+Завести аккаунт на Github, создать проект, установить GitExtensions.

6.11.16 (~3ч)
+Спроектировать модель улья более детально.
+Попробовать хоть как-то настроить Visual Studio, чтобы было приемлемо
	работать. *не получилось, компьютер вообще не тянет

7.11.16 (~1ч)
+Настроить всё, что нужно, на работе.
+Создать структуру проекта, проверить корректный запуск всех модулей.
	
8.11.16 (~2ч)
+Начать проектирование интерфейсов модели улья.
+Начать проектирование и реализацию тестовых View-моделей с использованием 
	View Model Locator.

9.11.16 (~2ч)
+Начать реализацию простого UI с тестовыми View-моделями (с использованием View	
	Model Locator).

10.11.16 (~2ч)
+Попробовать реализовать простой UI до конца (чтобы можно было проверить работу).
+Реализовать кастомный Dispatcher для имитации WPF-ного Dispatcher.BeginInvoke.
	*реализовано. Но лучше использовать стандартный класс CoreDispatcher.

11.11.16 (~1ч)
+Начать реализацию команд (ICommand) и подумать над оповещениями CanExecuteChanged.

12.11.16 (~2ч)
+Повторить паттерн Service Locator, ознакомиться с паттерном View Model Locator.
+Почитать про IOC, DIP, DI еще раз.

13.11.16 (~3ч)
+Ознакомиться вкратце с Universal Windows Platform.
+Почитать немного про многопоточность (TaskFactory, TPL, async/await и т.п.).

14.11.16 (~1ч)
+Реализовать service locator, подумать, где он будет использоваться и нужен ли
	вообще в данном приложении.

15.11.16 (~2ч)
+Реализовать более-менее приемлемый внешний вид согласно макету.

16.11.16 (~2ч)
+Протестировать, будет ли Task.Delay соответствовать заданному времени, хотя бы 
	примерно, если вызывается 10 000 раз одновременно (из разных потоков).
+Протестировать, будут ли нормально меняться числовые данные, если менять их
	из разных потоков одновременно (попробовать класс Interlocker или аналог).

17.11.16 (~2ч)
+Найти решение - альтернативу Task.Delay (кроме CancellationToken.WaitHandle.WaitOne).
	Можно попробовать таймеры.
	* await Task.Delay() (вместо Task.Delay().Wait()) работает, как ожидалось,
	предельно допустимое кол-во пчёл при этом - 20000.

18.11.16 (~1ч)
+Попробовать реализовать класс LongOperationSimulator для увеличения
	производительности (т.е. максимального общего количества пчёл). Проверить
	также отдельные ThreadPoolTimer'ы для каждой пчелы.

19.11.16 (~8ч)
+Почитать статью "Data Storage with UWP" 
	(http://www.codeproject.com/Articles/1109667/WebControls/).
+Законспектировать IoC, DI, DIP, Service Locator и их взаимосвязанность для 
	лучшего понимания предмета.
+Опираясь на задание, детально спроектировать модель приложения "Пасека", 
	включая все аспекты (UI, Domain, используемые паттерны Service Locator 
	и View Model Locator, обновление CanExecuteChanged команд и т.д.).
	
20.11.16 (~8ч)
+Переделать LongOperationSimulator так, чтобы было много разных таймеров
	с разными интервалами (создавались - по необходимости).
+Написать максимум программного кода дома в Notepad++ или в зависающей студии, 
	чтобы не тратить время на набор текста в Visual Studio в будни (можно
	рассмотреть Visual Studio Code Editor).
+Произвести рефакторинг LongOperationSimulator (хотя бы метод
	SimulateOperationAsync).
	
21.11.16 (~4ч)
+Перенести весь написанный в VS Code код в нужные проекты, отредактировать,
	чтобы решение компилировалось, отформатировать код и исправить
	предупреждения ReSharper'а.
+Везде изменить "Количество мёда" на long.
Заменить Dictionary в Service Locator на потокобезопасную версию.
	Протестировать Service Locator.
Заменить LongOperationSimulator на новый, заменить там Dictionary на
	ConcurrentDictionary, протестировать (в т.ч. протестировать, не 
	запускается ли первый проход таймера раньше времени, т.е. раньше 
	окончания первого интервала.
Реализовать классы для хранения состояния пасеки и соответствующие xml-схемы 
	и примеры документов.
Реализовать запись/чтение состояния пасеки из кэша. Если не получится, хотя 
	бы из файла xml (см. www.codeproject.com/Articles/1109667/WebControls/).
Доделать все View-модели и нормальное функционирование команд, протестировать
	визуально весь UI.
Подумать, что нужно будет тестировать. Составить в общих чертах	список тестов.

Очередь (избирательно, всё не получится) (до 25.11 включительно)
Убрать комментарии и заведомо уменьшенные (для быстроты выполнения тестов) 
	данные во всех тестах.
Настроить описание, имена сборок и протестировать release-версию.
Реализовать "очередь на выход", чтобы не все пчёлы улетали моментально.
Добавить в состояние улья - "ожидают входа в улей", и реализовать.
Настроить баланс игры, чтобы было более-менее интересно наблюдать.
Уточнить, делать ли обработку исключений, реализацию групповой работы пчёл,
	и переработку архитектуры пасеки, или достаточно текущего варианта 
	выполнения задания?

